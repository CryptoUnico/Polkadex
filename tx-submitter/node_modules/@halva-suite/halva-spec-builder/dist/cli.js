#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const HalvaSpecModifier_1 = require("./HalvaSpecModifier");
const AuraMiddleware_1 = require("./middlewares/AuraMiddleware");
const GrandpaMiddleware_1 = require("./middlewares/GrandpaMiddleware");
const BalanceMiddleware_1 = require("./middlewares/BalanceMiddleware");
const KeyloggerMiddleware_1 = require("./middlewares/KeyloggerMiddleware");
let a = 10;
let specPath = '';
let balance = '1152921504606847000';
let mnemonic;
const options = yargs_1.default
    .usage('Usage: $0 [options]')
    .option('a', { alias: 'count', describe: `Count (default: ${a})`, type: 'number' })
    .option('i', { alias: 'path', describe: 'Path to spec.json', type: 'string', demandOption: true })
    .option('m', { alias: 'mnemonic', describe: 'Mnemonic phrase (default: auto-gen)', type: 'string' })
    .option('am', { alias: 'auraMiddleware', describe: 'Add aura Authorities', type: 'boolean' })
    .option('bm', { alias: 'balanceMiddleware', describe: 'Add balance Authorities', type: 'boolean' })
    .option('gm', { alias: 'grandpaMiddleware', describe: 'Add grandpa Authorities', type: 'boolean' })
    .option('b', { alias: 'balance', describe: `Balance (default: ${balance})`, type: 'string' }).argv;
if (!options.i) {
    throw new Error('Path is empty');
}
else {
    specPath = options.i;
}
if (options.a) {
    a = options.a;
}
if (options.b) {
    balance = options.b;
}
if (options.m) {
    mnemonic = options.m;
}
function start() {
    return __awaiter(this, void 0, void 0, function* () {
        let builder = HalvaSpecModifier_1.HalvaSpecModifier.init(specPath, balance, a);
        if (mnemonic)
            builder = builder.setMnemonic(mnemonic);
        if (options.am)
            builder = builder.apply(AuraMiddleware_1.auraMiddleware);
        if (options.gm)
            builder = builder.apply(GrandpaMiddleware_1.grandpaMiddleware);
        if (options.bm)
            builder = builder.apply(BalanceMiddleware_1.balanceMiddleware);
        builder = builder.apply(KeyloggerMiddleware_1.keyloggerMiddleware);
        (yield builder.run()).output(specPath);
    });
}
start();
//# sourceMappingURL=cli.js.map